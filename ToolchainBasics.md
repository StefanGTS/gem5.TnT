## gem5 Tips & Tricks
### **Tips and tricks to make your life easier when dealing with gem5**

This repository contains tips and tricks about gem5. It is intended to gather and share useful hints about gem5, so that the learning process is accelerated.

Here you'll find some basics about toolchains. This is useful when exploring different architectures.

### **Toolchains**

#### GNU assembler toolchains

* **as** is the assembler and it converts human-readable assembly language programs into binary machine language code. It typically takes as input .s assembly files and outputs .o object files.

* **ld** is the linker and it is used to combine multiple object files by resolving their external symbol references and relocating their data sections, and outputting a single executable file. It typically takes as input .o object files and .ld linker scripts and outputs .out executable files.

* **objcopy** is a translation utility that copies and converts the contents of an object file from one format (e.g. .out) another (e.g. .bin).

* **objdump** is a disassembler but it can also display various other information about object files. It is often used to disassemble binary files (e.g. .out) into a canonical assembly language listing (e.g. .lst).

#### GNU binutils collection:

* **ar** is a utility for creating, modifying and extracting from archives.

* **nlmconv** converts object code into an NLM.

* **nm** lists symbols from object files.

* **ranlib** generates an index to the contents of an archive.

* **readelf** displays information from ELF-format object file.

* **size** displays the sections of an object or archive, and their sizes. 

* **strip** Discards symbols embedded in object files

#### Cross-compiler toolchain naming convention

A convention of the form **arch[-vendor][-os]-abi**

* The **arch** refers to the target architecture 

* The **vendor** nominally refers to the toolchain supplier

* The **os** refers to the target operating system, if any, and is used to decide which libraries (e.g. newlib, glibc, crt0, etc.) to link and which syscall conventions to employ

* The **abi** specifies which application binary interface convention is being employed, which ensures that binaries generated by different tools can interoperate

Examples:

* **arm-none-eabi** - targets ARM architecture, has no vendor, is for “bare metal” system, and complies with the ARM EABI - **bare metal ARM EABI**

* **i686-apple-darwin10-gcc-4.2.1** - gcc compiler targets the Intel i686 architecture, the vendor is Apple, and the OS is Darwin version 10.

* **arm-none-linux-gnueabi** targets the ARM architecture, has no vendor, is for the Linux operating system, and uses the GNU EABI. It is used to target **ARM-based Linux systems**.

* **arm-eabi** - Android ARM toolchains

Reference:

https://web.eecs.umich.edu/~prabal/teaching/eecs373-f12/notes/notes-toolchain.pdf

An **embedded-application binary interface (EABI)** specifies standard conventions for file formats, data types, register usage, stack frame organization, and function parameter passing of an embedded software program, for use with an embedded operating system.

Reference:

https://en.wikipedia.org/wiki/Application_binary_interface#Embedded_ABIs
