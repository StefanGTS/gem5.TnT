# Toolchains

## GNU assembler toolchains

* **as** is the assembler and it converts human-readable assembly language programs into binary machine language code. It typically takes as input .s assembly files and outputs .o object files.

* **ld** is the linker and it is used to combine multiple object files by resolving their external symbol references and relocating their data sections, and outputting a single executable file. It typically takes as input .o object files and .ld linker scripts and outputs .out executable files.

* **objcopy** is a translation utility that copies and converts the contents of an object file from one format (e.g. .out) another (e.g. .bin).

* **objdump** is a disassembler but it can also display various other information about object files. It is often used to disassemble binary files (e.g. .out) into a canonical assembly language listing (e.g. .lst).

## GNU binutils collection:

* **ar** is a utility for creating, modifying and extracting from archives.

* **nlmconv** converts object code into an NLM. • nm lists symbols from object files.

* **ranlib** generates an index to the contents of an archive.

* **readelf** displays information from ELF-format object file.

* **size** displays the sections of an object or archive, and their sizes. 

* **strip** Discards symbols embedded in object files

## Cross-compiler toolchain naming convention
A convention of the form **arch[-vendor][-os]-abi**

* The **arch** refers to the target architecture 

* The **vendor** nominally refers to the toolchain supplier

* The **os** refers to the target operating system, if any, and is used to decide which libraries (e.g. newlib, glibc, crt0, etc.) to link and which syscall conventions to employ

* The **abi** specifies which application binary interface convention is being employed, which ensures that binaries generated by different tools can interoperate

Examples:

* **arm-none-eabi** - targets ARM architecture, has no vendor, is for “bare metal” system, and complies with the ARM EABI - **bare metal ARM EABI**

* **i686-apple-darwin10-gcc-4.2.1** - gcc compiler targets the Intel i686 architecture, the vendor is Apple, and the OS is Darwin version 10.

* **arm-none-linux-gnueabi** targets the ARM architecture, has no vendor, is for the Linux operating system, and uses the GNU EABI. It is used to target **ARM-based Linux systems**.

* **arm-eabi** - Android ARM toolchains

Refer: https://web.eecs.umich.edu/~prabal/teaching/eecs373-f12/notes/notes-toolchain.pdf

An **embedded-application binary interface (EABI)** specifies standard conventions for file formats, data types, register usage, stack frame organization, and function parameter passing of an embedded software program, for use with an embedded operating system.

Refer: https://en.wikipedia.org/wiki/Application_binary_interface#Embedded_ABIs

## ARM architecture names

**armel**
It's ARM running in little-endian mode.

**armhf**
In Debian Linux, and derivatives such as Ubuntu, **armhf** (ARM hard float) refers to the ARMv7 architecture including the additional VFP3-D16 floating-point hardware extension (and Thumb-2). Software packages and cross-compiler tools use the **armhf** vs. **arm**/**armel** suffixes to differentiate.

Refer: https://en.wikipedia.org/wiki/ARM_architecture

The table below recaps which port names Debian/dpkg saw so far.

| name  | endianess    | status                                                                                                              |
|-------|--------------|---------------------------------------------------------------------------------------------------------------------|
| arm   | little-edian | original Debian arm port using original ABI ('OABI'), last release in Debian lenny; being retired in favor of armel |
| armel | little-edian | introduced in Debian lenny; EABI, actively maintained; targets armv4t; doesn't require an Floating Point Unit       |
| armeb | big-edian    | unofficial OABI port; inactive and dead                                                                             |
| armhf | either       | new ARM port using the hard-float ABI is 'armhf' (for 'hard-float')                                                 |

In practice **armel** will be used for older CPUs (armv4t, armv5, armv6), and **armhf** for newer CPUs (armv7+FPU).

GCC when built to target the GNU e.g. **arm-linux-gnueabi** triplet will support both the hard-float and soft-float calling conventions.

Refer: https://wiki.debian.org/ArmHardFloatPort
